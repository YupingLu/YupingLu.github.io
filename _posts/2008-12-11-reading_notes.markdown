---
author: yupinglu
comments: true
date: 2008-12-11 10:12:00+00:00
layout: post
slug: reading_notes
title: 读书笔记
wordpress_id: 43
categories:
- C++
tags:
- C++
---

尽管可以嵌套块，但不能将变量声明成和外部作用域中的变量相同的名称。例如以下的程序是非法的

//This program will not compile

class ScopeErr{

public static void main(String args[]){

int bar = 1;

{                           //create a new scope

int bar = 2;         //Compile-time error-bar already defined!

}

}

}

计算机语言的创新和发展基于两个根本性的因素：
1适应变化的环境和用途
2实现编程艺术的完善和提高
许多人认为C语言的产生标志着现代计算机语言时代的开始，它成功地综合处理了早期语言的矛盾属性。C语言是功能强大、高效的结构化语言，简单易学，而且它还包含了另一个几乎是无形中产生的影响：它是程序员的语言。在C语言诞生以前，计算机语言一般被当做学术试验而设计，或者由官方委员会设计。而C语言不同，它的设计、实现和开发是由真正从事编程工作的程序员完成的，它反映了现实编程工作的方法。它的特性经由实际使用该语言的人们不断提炼、测试、思考、再思考，使其称为程序员们愿意使用的语言，所以C语言迅速吸引了许多狂热的追随者。简而言之，C语言是由程序员设计并由他们使用的一种语言，而JAVA继承了这一传统。
在服务器端和客户端传输的是两大类对象：被动的信息和动态的、主动的程序
java设计的初衷：simple,secure,portable,object-oriented,robust,multithreaded,architecture-neutral,interpreted,high performance,distributed,dynamic

三个OOP原则：封装encapsulation，继承inheritance，多态polymorphism
类是一种逻辑结构，而对象是物理实体
多态常被说成：一个接口，多种方法。这就意味着一组相关的动作设计一个通用的接口
在Java中，所有的代码都必须常驻在类中。按照约定。类名必须与源程序的文件名相同，还要保证字母的大小写与类名相同。这是因为Java是大小写敏感的。
Java程序是空白符，标识符，字面值，注释，运算符，分隔符和关键字等的一个集合体
作为一个整体，Java是Java语言本身及其标准类的组合体
Java使用Unicode字符集，所以char的范围是16位
Java字符串必须位于同一行中，不存在续行转义序列
ps:Java不同于C/C++将字符串用数组实现，实际上是一种对象类型。因为Java将字符串当做对象实现，所以包含了广泛的字符串处理能力，且功能强大又易于使用
对C/C++程序员关于指针的注解:
如果你是一位有经验的C/C++程序员，则会知道这些语言提供对指针的支持。但是：Java不支持或不允许使用指针（或更恰当地说，Java不支持能由程序员访问和或修改指针）。Java不允许指针，是因为若支持的话，则会使Java程序突破Java执行环境和宿主(host)计算机之间的防火墙。（记住，指针可以赋予内存中的任何地址--甚至超越可Java运行时系统的地址。）由于C/c++大量使用指针，你可能认为不使用指针是一个重大的错误。但事实并非如此。Java是这样设计的：只要你位于Java执行的环境的边界以内，就从来没有必要使用指针，或者即使使用指针也不会带来任何的好处。
在C背景下，经常可以看到：
int done;
//---
if(!done) --- //Valid in C
if(done)--- //bot not in Java
在Java中，这些语句必须这样写：
if(done == 0) ---//This is Java-style
if(done != 0) ---
理由是：Java中定义的TRUE和FALSE的方式与C中不同，TRUE是任何非0的值，而FALSE表示0.在Java中TRUE和FALSE为非数字值，与0和非0无关。因此测试0或非0，必须显式地使用一个或多个关系运算符。

关于for-each风格的循环：因为迭代变量与后面的数组有关联，因此它是“只读”的。对迭代变量的赋值不会影响到后面的数组。换句话说不能通过将迭代变量赋值来改变数组的内容。
类是Java的核心，它是整个Java语言得以建立的逻辑构造，因为它定义了对象的形状和属性。
类是一个逻辑结构，对象是物理实体（即，对象在内存中占有空间）
如果将一个对象引用变量赋予另一个对象引用变量，则不是在创建对象的一个副本，而是在创建引用的一个副本。
总结如下：如果实例变量在类中定义，而访问该实例变量的代码不是类的一部分，则必须通过对象、使用点号运算符才能实现访问。但是，当访问实例变量的代码是同一个类的一部分时，变量可直接引用。对方法的操作也使如此。
构造函数在创建对象时立即初始化对象。它与所在的类具有相同的名称，在语法上与方法类似。一旦被定义，构造函数就会在对象被创建后，new操作完成前立即被自动调用。
实例变量隐藏：由于this能直接指向对象，因此利用它可解决实例变量和局部变量的名字空间冲突的问题，如
//use this to resolve name-space collisions.
Box(double width,double height,double depth) {
this.width = width;
this.height = height;
this.depth = depth;
}
警告：这种情形下使用this有时会引起混淆，有些程序员比较细心，不使用会隐藏实例变量的局部变量和形式参数的名称。当然，另外有些程序员的观点相反——使用相同名称能使程序更清楚，使用this克服实例变量隐藏的问题，这是一个好习惯。这只不过是个人的口味不同而已。
利用终结(finalization)，可以定义当垃圾回收器回收对象时指定要发生的动作。
変元传递：一般，在计算机语言中存在传递変元到子例程的两种方法。第一种称为“按值传递”(call-by-value)，这种方法将変元的值复制到子程序的形式参数中。因此，对子例程参数的修改对変元没有影响。第二种传递変元的方法称为“按引用传递”(call-by-reference)。在这种方法中，到変元的引用（而不是変元的值）传递给参数。在子例程内部，该引用被用来访问调用中指定的实际変元。这就意味着对子例程的修改将影响到用于调用子例程的変元。
Java的访问限定符包括：public,private,protected.protected只用于继承之中。
关于static成员最常见的例子是main()，之所以将它声明成static，是因为他必须在任何对象存在之前调用。本质上声明成static的实例变量就是全局变量，当声明它的类的对象时，不会出现static的任何副本，二而是所有的类的实例共享相同的static变量。
声明成是static有几个限制：
1它们只能调用其他static方法
2它们只能访问static数据
3它们不能以任何方式引用this或super
String类包一些含的方法：
boolean equals(String object)：检验两个字符串的相等性
int length()：获得字符串的长度
char charAt(int index)：获得字符串中指定索引处的字符
varargs，它是“可变长度変元”的缩写(variable-length arguments)。具有可变数量変元的方法称为可变変元方法(variable-arity method)，或者称为varargs方法。
可变长度参数必须是方法所声明的最后一个参数。
超类变量可以引用子类对象：当到子类对象的引用被赋值给超类引用变量时，只能访问那些由超类定义的对象部分。
super具有两种形式：
1调用超类的构造函数
super()总是指向直接位于所调用类之上的超类。甚至在多层次中也使如此。而且super()必须是子类构造函数中执行的第一条语句
2用于访问超类的成员，该成员已经被子类的成员所掩盖
方法重写构成了Java最强大的一个概念基础：动态方法调度(dynamic method dispatch),借助于这种机制，对一个已重写的方法的调用将在运行时，而不是在编译时解析。动态方法调度很重要，因为这关系到Java如何实现运行时多态的问题
包是类和其他从属包的容器，类是数据和代码的容器。
接口本质是抽象的方法，实现一个接口方法时必须声明为public
Thread类定义了几个帮助管理线程的方法：
getName    获得线程名
getPriority   获得线程优先级
isAlive   判断线程是否还在进行
join    等待线程终止
run   线程入口点
sleep 暂停线程一段时间
start   通过调用线程的运行方法启动线程
Java定义了两种创建线程的办法
1可以是以实现Runnable接口
2可以扩展Thread类
在多线程的情况下，如果有一个方法或者一组方法需要操纵对象的内部状态，就应该使用synchronized关键字来保护该状态不处于竞争状态。一旦一个线程进入一个实例的任何同步方法，别的线程将不能进入同一实例的其他同步方法，但是该实例的非同步方法仍然能够被调用
程序死锁，需要按Ctrl+C组合键结束程序，如果多线程程序偶尔锁住，死锁通常是第一个应该检查的情况。
所有枚举类型都自动包含两个预定义的方法：values()方法和valueof()方法
Java枚举类型是类类型，每一个枚举常量是它的枚举类型的一个对象
枚举不能继承另一个类，枚举不能是超类，这意味着枚举不能被扩展
类型包装器有Double,Float,Long,Integer,Short,Byte,Character,Boolean这几种，这些类提供了大量的方法，允许基本类型完全集成到Java的对象体系中
将一个值封装进一个对象的过程称为装箱(boxing)
将一个类型包装器中提取值的过程称为拆箱(unboxing)
在任何情况下注释都要放在声明的最前面
